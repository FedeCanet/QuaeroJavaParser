package java_quaero.parser;

import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol; 

parser code {:
	
	public static Lexer makeLexer(String input) throws Exception {
		return new Lexer(new StringReader(input));
	}
	
	public static Parser makeParser(String input) throws Exception {
		return new Parser(makeLexer(input));
	}
	
	public static Object parseString(String input) throws Exception {
		Parser parser = Parser.makeParser(input);
		Symbol result = parser.parse();
		return result.value;
	}
	
	public Map<String, Boolean> state = new HashMap<String, Boolean>();
	
:}

// Rules

terminal NEG, PARI, PARD, FALSE, TRUE, CONJ, DISY, COND, BICOND, PUNTOCOMA, IGUAL;
terminal String ID;
non terminal Boolean prop, valor;
non terminal Map<String, Boolean> ini;
non terminal ins;

precedence left DISY;
precedence left COND;
precedence left BICOND;
precedence left CONJ;
precedence left NEG;

ini ::= ins:ins {: RESULT = parser.state; :}
	| 	ins:ins ini:ini {: RESULT = parser.state; :}
	; 

prop ::= NEG:n prop:prop {: RESULT = !prop; :}
	|	PARI:pari prop:prop PARD:pard {: RESULT = (prop); :}
	|	prop:prop1 CONJ:cond prop:prop2 {: RESULT = prop1 && prop2; :}
	|	prop:prop1 DISY:disy prop:prop2 {: RESULT = prop1 || prop2; :}
	|	prop:prop1 COND:cond prop:prop2 {: RESULT = prop1 ? prop2 : true; :}
	|	prop:prop1 BICOND:bicond prop:prop2 {: RESULT = prop1.equals(prop2); :}
	|	valor:v {: RESULT = v; :}
	|	ID:id	{: RESULT = parser.state.get(id); :}
	 ;
	    
valor ::= TRUE 
		{: RESULT = new Boolean(true); :}
	|	FALSE
		{: RESULT = new Boolean(false); :}
	;
	
ins ::= ID:id IGUAL:igual prop:prop PUNTOCOMA:pc
		{: RESULT = parser.state.put(id, prop); :}

	| 	prop:prop PUNTOCOMA:pc
		{: RESULT = parser.state.get(prop);:}
	;	